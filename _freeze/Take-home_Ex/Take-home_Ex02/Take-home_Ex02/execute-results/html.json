{
  "hash": "311f4c93affb644be50a82bc3ec30f23",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-Home Exercise 2\"\nauthor: \"Immanuel Leong\"\ndate: \"September 25, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n\n# **Take-home Exercise 2: Application of Geospatial Analysis Methods to Discover Thailand Drug Abuse at the Province Level**\n\n## 1.0 Overview\n\nDrug abuse is associated with significant negative health, financial and social consequences. Yet, illicit drug consumption remains highly prevalent and continues to be a growing problem worldwide. In 2021, 1 in 17 people aged 15–64 in the world had used a drug in the past 12 months. Notwithstanding population growth, the estimated number of drug users grew from 240 million in 2011 to 296 million in 2021.\n\nIn Thailand, drug abuse is a major social issue. There are about 2.7 million youths using drugs in Thailand. Among youths aged between 15 and 19 years, there are about 300,000 who have needs for drug treatment. Most of Thai youths involved with drugs are vocational-school students, which nearly doubles in number compared to secondary-school students.\n\n## **1.1 Objectives**\n\nWe are interested to discover:\n\n-   if the key indicators of drug abuse of Thailand are independent from space.\n\n-   If the indicators of drug abuse is indeed spatially dependent, then, we would like to detect where are the clusters and outliers, and the hotspots.\n\n-   Last but not least, we are also interested to investigate how the observations above evolve over time.\n\n## 1.2 Task\n\nThe specific tasks of this take-home exercise are as follows:\n\n-   Using appropriate function of **sf** and **tidyverse**, preparing the following geospatial data layer:\n\n    -   a study area layer in sf polygon features. It must be at [province level](https://en.wikipedia.org/wiki/Provinces_of_Thailand) (including Bangkok) of Thailand.\n\n    -   a drug abuse indicators layer within the study area in sf polygon features.\n\n-   Using the extracted data, perform global spatial autocorrelation analysis by using [sfdep methods](https://is415-gaa-tskam.netlify.app/in-class_ex/in-class_ex05/in-class_ex05-glsa).\n\n-   Using the extracted data, perform local spatial autocorrelation analysis by using [sfdep methods](https://r4gdsa.netlify.app/chap10.html).\n\n-   Describe the spatial patterns revealed by the analysis above.\n\n## 2.0 Data\n\nThe following two data sets will be used:\n\n-   `thai_drug_offenses_2017_2022.csv` This dataset presents statistics related to different types of drug offenses in Thailand, categorized by fiscal year, and provides insights into the prevalence of various drug-related cases and their distribution across different provinces. It was downloaded from <https://www.kaggle.com/datasets/thaweewatboy/thailand-drug-offenses-2017-2022>.\n\n-   `tha_admbnda_adm1_rtsd_20220121` This dataset provides information on Thailand province boundaries in shapefile format. It was downloaded from the [Humanitarian Data Exchange](#0), a service provided by the United Nations Office for the Coordination of Humanitarian Affairs (OCHA).\n\n## 3.0 Setup\n\nFor this exercise, the following R packages are used:\n\n-   [**tidyverse**](https://www.tidyverse.org/), a collection of R packages designed for data science, and which provides functions to import, transform, and visualise the data.\n\n-   [**sf**](https://r-spatial.github.io/sf/), to import, manage and process vector-based geospatial data in R.\n\n-   [**sfdep**](https://cran.r-project.org/web/packages/sfdep/index.html), which creates an sf and tidyverse friendly interface to the **spdep** package that is used to compute spatial weights, global and local spatial autocorrelation statistics\n\n-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html)**,** which provides functions for plotting cartographic quality choropleth maps.\n\n-   [**Kendall**](https://cran.r-project.org/web/packages/Kendall/index.html), which computes the Kendall rank correlation and Mann-Kendall trend test. This will be necessary for us to perform emerging hot spot analysis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, sf, sfdep, tmap, Kendall)\n```\n:::\n\n\n\n## 4.0 Importing the Data\n\n### 4.1 Importing Spatial Data\n\nImport `tha_admbnda_adm1_rtsd_20220121` as a simple features object, which we name `thailand`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthailand <- st_read(dsn = \"data/geospatial\", layer = \"tha_admbnda_adm1_rtsd_20220121\")\n```\n:::\n\n\n\n`thailand` has a total of 77 features, and is projected in WGS 84.\n\nWe save `thailand` with the *write_rds()* function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(thailand, \"data/rds/thailand.rds\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nVerify that all the geometries in `thailand` are valid.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(which(st_is_valid(thailand) == TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 77\n```\n\n\n:::\n:::\n\n\n\nSometimes, when importing geospatial data into R, the coordinate system of the source data is wrongly assigned during the importing process. Check the CRS of `thailand`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(thailand)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n```\n\n\n:::\n:::\n\n\n\nThe EPSG code indicated is 4326, which is correct since the data is projected in WGS 84.\n\n### 4.2 Importing Aspatial Data\n\nSince `thai_drug_offenses_2017_2022.csv` is in csv format, we used *read_csv()* of the **readr** package (part of the **tidyverse)** to import it.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrugs <- read_csv(\"data/aspatial/thai_drug_offenses_2017_2022.csv\")\n\nglimpse(drugs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 7,392\nColumns: 5\n$ fiscal_year            <dbl> 2017, 2017, 2017, 2017, 2017, 2017, 2017, 2017,…\n$ types_of_drug_offenses <chr> \"drug_use_cases\", \"drug_use_cases\", \"drug_use_c…\n$ no_cases               <dbl> 11871, 200, 553, 450, 378, 727, 820, 69, 127, 2…\n$ province_th            <chr> \"กรุงเทพมหานคร\", \"ชัยนาท\", \"นนทบุรี\", \"ปทุมธานี\", \"พร…\n$ province_en            <chr> \"Bangkok\", \"Chai Nat\", \"Nonthaburi\", \"Pathum Th…\n```\n\n\n:::\n:::\n\n\n\nThe data on the number of drug-related cases in `drugs` is categorized by fiscal year, type of drug offense, and province. We derive the total number of drug-related cases in each province, in each fiscal year, using *group_by()* and *summarize()* of **dplyr** (part of the **tidyverse)**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrugs_all <- drugs %>% \n  group_by(fiscal_year, province_en, province_th) %>%\n  summarize(cases = sum(no_cases))\n\nglimpse(drugs_all)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 462\nColumns: 4\nGroups: fiscal_year, province_en [462]\n$ fiscal_year <dbl> 2017, 2017, 2017, 2017, 2017, 2017, 2017, 2017, 2017, 2017…\n$ province_en <chr> \"Amnat Charoen\", \"Ang Thong\", \"Bangkok\", \"Buri Ram\", \"Chac…\n$ province_th <chr> \"อำนาจเจริญ\", \"อ่างทอง\", \"กรุงเทพมหานคร\", \"บุรีรัมย์\", \"ฉะเชิงเทรา…\n$ cases       <dbl> 5076, 1614, 60067, 5061, 9318, 1536, 6435, 4021, 15620, 88…\n```\n\n\n:::\n:::\n\n\n\nNext, we use *pivot_wider()* of **dplyr** so that each row contains the data for a single province, and each column contains the data for a single fiscal year.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrugs_all1 <- drugs_all %>%\n  pivot_wider(names_from = \"fiscal_year\", values_from = \"cases\")\n\nglimpse(drugs_all1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 77\nColumns: 8\nGroups: province_en [77]\n$ province_en <chr> \"Amnat Charoen\", \"Ang Thong\", \"Bangkok\", \"Buri Ram\", \"Chac…\n$ province_th <chr> \"อำนาจเจริญ\", \"อ่างทอง\", \"กรุงเทพมหานคร\", \"บุรีรัมย์\", \"ฉะเชิงเทรา…\n$ `2017`      <dbl> 5076, 1614, 60067, 5061, 9318, 1536, 6435, 4021, 15620, 88…\n$ `2018`      <dbl> 5651, 2717, 70215, 8774, 8685, 2195, 11334, 5430, 18944, 1…\n$ `2019`      <dbl> 7339, 2781, 62291, 12393, 9086, 3215, 14796, 5862, 21722, …\n$ `2020`      <dbl> 3949, 2636, 44169, 6897, 9203, 3119, 8333, 5877, 22574, 14…\n$ `2021`      <dbl> 8961, 3513, 37318, 15960, 12344, 3128, 15131, 6635, 28778,…\n$ `2022`      <dbl> 4459, 2907, 12420, 8267, 4878, 2117, 8468, 3648, 14174, 96…\n```\n\n\n:::\n:::\n\n\n\n## 4.3 **Performing relational join**\n\nThe code chunk below will be used to update the attribute table of `thailand` with the attribute fields of the`drugs_all1` dataframe, retaining only the relevant columns. This is performed by using *inner_join()* of **dplyr** package. We join the data frames on the English-language names of each province.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthailand_drugs <- left_join(thailand, drugs_all1, by = c(\"ADM1_EN\" = \"province_en\")) %>%\n  select(3, 18:24)\n\nglimpse(thailand_drugs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 77\nColumns: 8\n$ ADM1_EN  <chr> \"Bangkok\", \"Samut Prakan\", \"Nonthaburi\", \"Pathum Thani\", \"Phr…\n$ `2017`   <dbl> 60067, 12452, 7348, 7616, 6221, 1614, NA, 1574, 1536, 4288, 1…\n$ `2018`   <dbl> 70215, 17656, 9583, 11005, 8555, 2717, NA, 2117, 2195, 5766, …\n$ `2019`   <dbl> 62291, 23295, 11347, 14643, 10631, 2781, NA, 2586, 3215, 6391…\n$ `2020`   <dbl> 44169, 14615, 7064, 8744, 8549, 2636, NA, 2209, 3119, 5632, 2…\n$ `2021`   <dbl> 37318, 14002, 10290, 8927, 8013, 3513, NA, 2872, 3128, 6744, …\n$ `2022`   <dbl> 12420, 7366, 3912, 5571, 4890, 2907, NA, 1744, 2117, 3585, 86…\n$ geometry <MULTIPOLYGON [°]> MULTIPOLYGON (((100.6139 13..., MULTIPOLYGON (((…\n```\n\n\n:::\n:::\n\n\n\nThere are 77 rows, corresponding to Thailand's 77 provinces (including Bangkok). However, on further examination, we notice that values from `drugs_all1` are missing for two provinces: Lop Buri and Buengkan.\n\nThis is due to a discrepancy in the English-language transcriptions of these 2 provinces in `drugsall1` and `thailand`. To solve this, we join the two data frames using the Thai-language province names instead.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthailand_drugs <- left_join(thailand, drugs_all1, by = c(\"ADM1_TH\" = \"province_th\")) %>%\n  select(3, 18:24)\n\nglimpse(thailand_drugs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 77\nColumns: 8\n$ ADM1_EN  <chr> \"Bangkok\", \"Samut Prakan\", \"Nonthaburi\", \"Pathum Thani\", \"Phr…\n$ `2017`   <dbl> 60067, 12452, 7348, 7616, 6221, 1614, 5872, 1574, 1536, 4288,…\n$ `2018`   <dbl> 70215, 17656, 9583, 11005, 8555, 2717, 9547, 2117, 2195, 5766…\n$ `2019`   <dbl> 62291, 23295, 11347, 14643, 10631, 2781, 10043, 2586, 3215, 6…\n$ `2020`   <dbl> 44169, 14615, 7064, 8744, 8549, 2636, 8132, 2209, 3119, 5632,…\n$ `2021`   <dbl> 37318, 14002, 10290, 8927, 8013, 3513, 9254, 2872, 3128, 6744…\n$ `2022`   <dbl> 12420, 7366, 3912, 5571, 4890, 2907, 4647, 1744, 2117, 3585, …\n$ geometry <MULTIPOLYGON [°]> MULTIPOLYGON (((100.6139 13..., MULTIPOLYGON (((…\n```\n\n\n:::\n:::\n\n\n\nThe values for all provinces are now reflected.\n\n## 4.4 Visualising Drug Abuse Indicators\n\nWe can now plot a choropleth map showing the distribution of drug-related cases in Thailand by province for each year between 2017 and 2022, using the **tmap** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n\nthailand_2017 <- tm_shape(thailand_drugs) +\n  tm_fill(\"2017\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.height = 0.45, legend.width = 0.5, frame = TRUE)\n\nthailand_2018 <- tm_shape(thailand_drugs) +\n  tm_fill(\"2018\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.height = 0.45, legend.width = 0.5, frame = TRUE)\n\nthailand_2019 <- tm_shape(thailand_drugs) +\n  tm_fill(\"2019\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.height = 0.45, legend.width = 0.5, frame = TRUE)\n\nthailand_2020 <- tm_shape(thailand_drugs) +\n  tm_fill(\"2020\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.height = 0.45, legend.width = 0.5, frame = TRUE)\n\nthailand_2021 <- tm_shape(thailand_drugs) +\n  tm_fill(\"2021\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.height = 0.45, legend.width = 0.5, frame = TRUE)\n\nthailand_2022 <- tm_shape(thailand_drugs) +\n  tm_fill(\"2022\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.height = 0.45, legend.width = 0.5, frame = TRUE)\n\ntmap_arrange(thailand_2017, thailand_2018, thailand_2019, thailand_2020, thailand_2021, thailand_2022, asp = 1, nrow = 2)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n## **5.0 Global Measures of Spatial Autocorrelation**\n\nIn this section, we compute global spatial autocorrelation statistics and perform spatial complete randomness test for global spatial autocorrelation.\n\n### **5.1 Computing Contiguity Spatial Weights**\n\nBefore we can compute the global spatial autocorrelation statistics, we need to construct a spatial weights matrix of the study area. The spatial weights matrix is used to define the neighbourhood relationships between the provinces.\n\nIn the code chunk below, *st_contiguity()* of **sfdep** is used to compute a contiguity weight matrix. This function builds a neighbours list `nb` based on provinces with contiguous boundaries. We use the Queen criteria to calculate our neighbours list.\n\nThen, *st_weights()* is used to to assign weights to neighboring polygons. We use row-standardised weights (style = \"W\"). This means that for each province *i*, each neighbouring province is assigned an equal weight of 1/(number of neighbours of *i*). The spatially lagged drug-related case count of province *i* is calculated by summing the weighted case count values of its neighbours.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- thailand_drugs %>%\n  mutate(nb = st_contiguity(geometry, queen = TRUE),\n         wt = st_weights(nb, style = \"W\", allow_zero = TRUE),\n         .before = 1)\n\nwm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 77 features and 9 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 97.34336 ymin: 5.613038 xmax: 105.637 ymax: 20.46507\nGeodetic CRS:  WGS 84\nFirst 10 features:\n                            nb\n1          2, 3, 4, 15, 59, 60\n2                        1, 15\n3                  1, 4, 5, 59\n4          1, 3, 5, 10, 15, 17\n5       3, 4, 6, 7, 10, 58, 59\n6                  5, 7, 8, 58\n7  5, 6, 8, 10, 19, 25, 48, 55\n8              6, 7, 9, 48, 58\n9                8, 48, 49, 58\n10             4, 5, 7, 17, 19\n                                                                            wt\n1             0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667\n2                                                                     0.5, 0.5\n3                                                       0.25, 0.25, 0.25, 0.25\n4             0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667\n5  0.1428571, 0.1428571, 0.1428571, 0.1428571, 0.1428571, 0.1428571, 0.1428571\n6                                                       0.25, 0.25, 0.25, 0.25\n7                       0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125\n8                                                      0.2, 0.2, 0.2, 0.2, 0.2\n9                                                       0.25, 0.25, 0.25, 0.25\n10                                                     0.2, 0.2, 0.2, 0.2, 0.2\n                    ADM1_EN  2017  2018  2019  2020  2021  2022\n1                   Bangkok 60067 70215 62291 44169 37318 12420\n2              Samut Prakan 12452 17656 23295 14615 14002  7366\n3                Nonthaburi  7348  9583 11347  7064 10290  3912\n4              Pathum Thani  7616 11005 14643  8744  8927  5571\n5  Phra Nakhon Si Ayutthaya  6221  8555 10631  8549  8013  4890\n6                 Ang Thong  1614  2717  2781  2636  3513  2907\n7                  Lop Buri  5872  9547 10043  8132  9254  4647\n8                 Sing Buri  1574  2117  2586  2209  2872  1744\n9                  Chai Nat  1536  2195  3215  3119  3128  2117\n10                 Saraburi  4288  5766  6391  5632  6744  3585\n                         geometry\n1  MULTIPOLYGON (((100.6139 13...\n2  MULTIPOLYGON (((100.7306 13...\n3  MULTIPOLYGON (((100.3415 14...\n4  MULTIPOLYGON (((100.8916 14...\n5  MULTIPOLYGON (((100.5131 14...\n6  MULTIPOLYGON (((100.3332 14...\n7  MULTIPOLYGON (((101.3453 15...\n8  MULTIPOLYGON (((100.3691 15...\n9  MULTIPOLYGON (((100.1199 15...\n10 MULTIPOLYGON (((101.3994 15...\n```\n\n\n:::\n:::\n\n\n\nNotice a warning message that some observations have no neighbours. Examining `wm_q`, this is due to the province of Phuket, which consists of islands and does not have contiguous boundaries with any other province.\n\n### **5.2 Global Measures of Spatial Autocorrelation: Moran's I**\n\n#### 5.2.1 Computing Global Moran’ I\n\nIn the code chunk below, *global_moran()* is used to compute the Moran’s I value for each year. The global Moran's I value measures spatial autocorrelation for the entire study area.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoranI_2017 <- global_moran(wm_q$\"2017\",\n                       wm_q$nb,\n                       wm_q$wt,\n                       zero.policy = TRUE)\n\nmoranI_2018 <- global_moran(wm_q$\"2018\",\n                       wm_q$nb,\n                       wm_q$wt,\n                       zero.policy = TRUE)\n\nmoranI_2019 <- global_moran(wm_q$\"2019\",\n                       wm_q$nb,\n                       wm_q$wt,\n                       zero.policy = TRUE)\n\n\nmoranI_2020 <- global_moran(wm_q$\"2020\",\n                       wm_q$nb,\n                       wm_q$wt,\n                       zero.policy = TRUE)\n\n\nmoranI_2021 <- global_moran(wm_q$\"2021\",\n                       wm_q$nb,\n                       wm_q$wt,\n                       zero.policy = TRUE)\n\n\nmoranI_2022 <- global_moran(wm_q$\"2022\",\n                       wm_q$nb,\n                       wm_q$wt,\n                       zero.policy = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(moranI_2017)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ I: num 0.135\n $ K: num 31.4\n```\n\n\n:::\n\n```{.r .cell-code}\nglimpse(moranI_2018)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ I: num 0.118\n $ K: num 30.4\n```\n\n\n:::\n\n```{.r .cell-code}\nglimpse(moranI_2019)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ I: num 0.157\n $ K: num 18.8\n```\n\n\n:::\n\n```{.r .cell-code}\nglimpse(moranI_2020)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ I: num 0.131\n $ K: num 12.3\n```\n\n\n:::\n\n```{.r .cell-code}\nglimpse(moranI_2021)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ I: num 0.202\n $ K: num 5.54\n```\n\n\n:::\n\n```{.r .cell-code}\nglimpse(moranI_2022)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ I: num 0.204\n $ K: num 3.34\n```\n\n\n:::\n:::\n\n\n\nSince the computed global Moran's I values are close to zero in every year, it appears that drug-related case levels are distributed randomly over space in Thailand and there is no spatial autocorrelation.\n\n#### 5.2.2 Performing Global Moran’s I Permutation test\n\nFor a more rigorous analysis, we perform a statistical test using Monte Carlo simulation. This is done using *global_moran_perm().* To ensure reproducibility, we set a seed before performing the simulations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\nglobal_moran_perm(wm_q$\"2017\", wm_q$nb, wm_q$wt, nsim = 99, zero.policy = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.13314, observed rank = 98, p-value = 0.04\nalternative hypothesis: two.sided\n```\n\n\n:::\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$\"2018\", wm_q$nb, wm_q$wt, nsim = 99, zero.policy = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.11637, observed rank = 100, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n\n\n:::\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$\"2019\", wm_q$nb, wm_q$wt, nsim = 99, zero.policy = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.15541, observed rank = 97, p-value = 0.06\nalternative hypothesis: two.sided\n```\n\n\n:::\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$\"2020\", wm_q$nb, wm_q$wt, nsim = 99, zero.policy = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.1296, observed rank = 98, p-value = 0.04\nalternative hypothesis: two.sided\n```\n\n\n:::\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$\"2021\", wm_q$nb, wm_q$wt, nsim = 99, zero.policy = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.19889, observed rank = 100, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n\n\n:::\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$\"2022\", wm_q$nb, wm_q$wt, nsim = 99, zero.policy = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.20113, observed rank = 99, p-value = 0.02\nalternative hypothesis: two.sided\n```\n\n\n:::\n:::\n\n\n\nAt alpha = 0.05, the p-values in every year other than 2019 are smaller than the alpha value, which means that for these years, we have enough statistical evidence to reject the null hypothesis that the spatial distribution of drug-related case levels is random. Since the Moran’s I statistics is greater than 0, we infer that the spatial distribution shows signs of clustering in all the years apart from 2019 (i.e. in these years, provinces with similar drug-related case levels are likely to be clustered together).\n\nOn the other hand, the p-value in 2019 is larger than the alpha value of 0.05, which means that we do not have enough evidence to reject the null hypothesis that the spatial distribution of drug-related case levels is random for 2019.\n\n### **5.3 Global Measures of Spatial Autocorrelation: Geary’s C**\n\nWe can perform the simulations using the Geary's C statistic instead.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\n\nglobal_c_perm(wm_q$\"2017\", wm_q$nb, wm_q$wt, nsim = 99, allow_zero = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.99196, observed rank = 59, p-value = 0.59\nalternative hypothesis: greater\n```\n\n\n:::\n\n```{.r .cell-code}\nglobal_c_perm(wm_q$\"2018\", wm_q$nb, wm_q$wt, nsim = 99, allow_zero = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 1.0014, observed rank = 42, p-value = 0.42\nalternative hypothesis: greater\n```\n\n\n:::\n\n```{.r .cell-code}\nglobal_c_perm(wm_q$\"2019\", wm_q$nb, wm_q$wt, nsim = 99, allow_zero = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.92999, observed rank = 39, p-value = 0.39\nalternative hypothesis: greater\n```\n\n\n:::\n\n```{.r .cell-code}\nglobal_c_perm(wm_q$\"2020\", wm_q$nb, wm_q$wt, nsim = 99, allow_zero = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.94641, observed rank = 26, p-value = 0.26\nalternative hypothesis: greater\n```\n\n\n:::\n\n```{.r .cell-code}\nglobal_c_perm(wm_q$\"2021\", wm_q$nb, wm_q$wt, nsim = 99, allow_zero = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.86448, observed rank = 14, p-value = 0.14\nalternative hypothesis: greater\n```\n\n\n:::\n\n```{.r .cell-code}\nglobal_c_perm(wm_q$\"2022\", wm_q$nb, wm_q$wt, nsim = 99, allow_zero = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.84715, observed rank = 6, p-value = 0.06\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n\nIn contrast to simulations of the global Moran's I statistics, the p-values are larger than the alpha value of 0.05 in every year, which means that we do not have enough evidence to reject the null hypothesis that the spatial distribution of drug-related case levels is random.\n\n## **6.0 Local Measures of Spatial Autocorrelation**\n\nLocal Measures of Spatial Autocorrelation (LMSA) focus on the relationships between each observation and its surroundings, rather than providing a single summary of these relationships across the entire study area.\n\nGiven a set of geospatial features and an analysis field, the spatial statistics identify spatial clusters of features with high or low values, as well as outliers.\n\n### 6.1 Local **Measures of Spatial Autocorrelation: Moran's I**\n\n#### 6.1.1 **Computing Local Moran's I**\n\nLocal Moran’s I is the most popular spatial statistical method used. We compute Local Moran’s I drug-related case levels at the provincial level for each year by using *local.moran()* of **sfdep**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\nlisa2017 <- wm_q %>% \n  mutate(local_moran = local_moran(.$\"2017\", nb, wt, nsim = 99, zero.policy = TRUE),\n         .before = 1) %>%\n  unnest(local_moran) %>%\n  select(ii, p_ii, median, ADM1_EN, geometry)\n\nlisa2017 %>% filter(p_ii < 0.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 7 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 98.6116 ymin: 7.467277 xmax: 101.9901 ymax: 14.27595\nGeodetic CRS:  WGS 84\n# A tibble: 7 × 5\n       ii     p_ii median    ADM1_EN                                    geometry\n*   <dbl>    <dbl> <fct>     <chr>                            <MULTIPOLYGON [°]>\n1  2.56   2.00e-26 High-High Samut Prakan  (((100.7306 13.71713, 100.7307 13.71…\n2  0.0583 4.84e- 4 High-High Nonthaburi    (((100.3415 14.10079, 100.3415 14.10…\n3  0.0737 4.80e- 4 High-High Pathum Thani  (((100.8916 14.24576, 100.8916 14.24…\n4  0.293  6.13e- 3 High-High Chachoengsao  (((101.0612 13.97613, 101.0625 13.97…\n5  0.0964 4.62e- 3 High-High Nakhon Pathom (((100.2231 14.17725, 100.2262 14.17…\n6 -0.706  8.08e- 6 Low-High  Samut Sakhon  (((100.3091 13.7217, 100.3091 13.721…\n7  0.0769 2.20e- 2 High-High Krabi         (((99.11329 7.489274, 99.11337 7.489…\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\nlisa2018 <- wm_q %>% \n  mutate(local_moran = local_moran(.$\"2018\", nb, wt, nsim = 99, zero.policy = TRUE),\n         .before = 1) %>%\n  unnest(local_moran) %>%\n  select(ii, p_ii, median, ADM1_EN, geometry)\n\nlisa2018 %>% filter(p_ii < 0.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 99.8141 ymin: 13.17847 xmax: 101.9901 ymax: 14.27595\nGeodetic CRS:  WGS 84\n# A tibble: 6 × 5\n       ii     p_ii median    ADM1_EN                                    geometry\n*   <dbl>    <dbl> <fct>     <chr>                            <MULTIPOLYGON [°]>\n1  3.40   2.32e-24 High-High Samut Prakan  (((100.7306 13.71713, 100.7307 13.71…\n2  0.133  3.65e- 4 High-High Nonthaburi    (((100.3415 14.10079, 100.3415 14.10…\n3  0.239  8.17e- 4 High-High Pathum Thani  (((100.8916 14.24576, 100.8916 14.24…\n4 -0.0293 4.61e- 3 High-High Chachoengsao  (((101.0612 13.97613, 101.0625 13.97…\n5  0.110  2.75e- 3 High-High Nakhon Pathom (((100.2231 14.17725, 100.2262 14.17…\n6 -0.854  5.05e- 6 Low-High  Samut Sakhon  (((100.3091 13.7217, 100.3091 13.721…\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\nlisa2019 <- wm_q %>% \n  mutate(local_moran = local_moran(.$\"2019\", nb, wt, nsim = 99, zero.policy = TRUE),\n         .before = 1) %>%\n  unnest(local_moran) %>%\n  select(ii, p_ii, median, ADM1_EN, geometry)\n\nlisa2019 %>% filter(p_ii < 0.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 99.8141 ymin: 13.17847 xmax: 101.9901 ymax: 14.27595\nGeodetic CRS:  WGS 84\n# A tibble: 6 × 5\n       ii     p_ii median    ADM1_EN                                    geometry\n*   <dbl>    <dbl> <fct>     <chr>                            <MULTIPOLYGON [°]>\n1  4.73   5.42e-15 High-High Samut Prakan  (((100.7306 13.71713, 100.7307 13.71…\n2  0.317  8.02e- 4 High-High Nonthaburi    (((100.3415 14.10079, 100.3415 14.10…\n3  0.509  6.71e- 3 High-High Pathum Thani  (((100.8916 14.24576, 100.8916 14.24…\n4 -0.0738 4.65e- 3 High-High Chachoengsao  (((101.0612 13.97613, 101.0625 13.97…\n5 -0.0606 1.03e- 2 High-High Nakhon Pathom (((100.2231 14.17725, 100.2262 14.17…\n6 -0.845  5.35e- 4 Low-High  Samut Sakhon  (((100.3091 13.7217, 100.3091 13.721…\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\nlisa2020 <- wm_q %>% \n  mutate(local_moran = local_moran(.$\"2020\", nb, wt, nsim = 99, zero.policy = TRUE),\n         .before = 1) %>%\n  unnest(local_moran) %>%\n  select(ii, p_ii, median, ADM1_EN, geometry)\n\nlisa2020 %>% filter(p_ii < 0.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 7 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 98.6116 ymin: 7.090332 xmax: 101.9901 ymax: 14.14025\nGeodetic CRS:  WGS 84\n# A tibble: 7 × 5\n       ii     p_ii median    ADM1_EN                                    geometry\n*   <dbl>    <dbl> <fct>     <chr>                            <MULTIPOLYGON [°]>\n1  2.36   9.75e-11 High-High Samut Prakan        (((100.7306 13.71713, 100.7307…\n2 -0.283  7.22e- 3 High-High Nonthaburi          (((100.3415 14.10079, 100.3415…\n3  0.0741 1.88e- 2 High-High Chachoengsao        (((101.0612 13.97613, 101.0625…\n4 -0.691  3.15e- 2 Low-High  Samut Sakhon        (((100.3091 13.7217, 100.3091 …\n5  2.48   3.77e- 2 High-High Nakhon Si Thammarat (((99.77467 9.313729, 99.77478…\n6  0.237  3.28e- 3 High-High Krabi               (((99.11329 7.489274, 99.11337…\n7 -0.632  2.29e- 2 Low-High  Phatthalung         (((99.96416 7.90199, 99.9642 7…\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\nlisa2021 <- wm_q %>% \n  mutate(local_moran = local_moran(.$\"2021\", nb, wt, nsim = 99, zero.policy = TRUE),\n         .before = 1) %>%\n  unnest(local_moran) %>%\n  select(ii, p_ii, median, ADM1_EN, geometry)\n\nlisa2021 %>% filter(p_ii < 0.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 98.6116 ymin: 7.090332 xmax: 100.9639 ymax: 16.19126\nGeodetic CRS:  WGS 84\n# A tibble: 6 × 5\n      ii     p_ii median    ADM1_EN                                     geometry\n*  <dbl>    <dbl> <fct>     <chr>                             <MULTIPOLYGON [°]>\n1  0.612 0.000687 High-High Samut Prakan (((100.7306 13.71713, 100.7307 13.7168…\n2  0.439 0.0232   Low-Low   Nakhon Sawan (((100.0266 16.189, 100.0267 16.18889,…\n3  0.674 0.0243   Low-Low   Ratchaburi   (((99.8821 13.94977, 99.88218 13.94976…\n4  0.553 0.0216   Low-Low   Suphan Buri  (((99.37118 15.05073, 99.37454 15.0495…\n5 -0.103 0.00782  High-High Krabi        (((99.11329 7.489274, 99.11337 7.48927…\n6 -0.595 0.0105   Low-High  Phatthalung  (((99.96416 7.90199, 99.9642 7.901912,…\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\nlisa2022 <- wm_q %>% \n  mutate(local_moran = local_moran(.$\"2022\", nb, wt, nsim = 99, zero.policy = TRUE),\n         .before = 1) %>%\n  unnest(local_moran) %>%\n  select(ii, p_ii, median, ADM1_EN, geometry)\n\nlisa2022 %>% filter(p_ii < 0.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 11 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 99.01629 ymin: 7.090332 xmax: 104.4353 ymax: 18.30525\nGeodetic CRS:  WGS 84\n# A tibble: 11 × 5\n       ii    p_ii median    ADM1_EN                                     geometry\n *  <dbl>   <dbl> <fct>     <chr>                             <MULTIPOLYGON [°]>\n 1 -0.185 0.0221  High-High Surin            (((103.1336 15.47831, 103.1343 15.…\n 2 -1.37  0.00598 Low-High  Nong Bua Lam Phu (((102.2866 17.69207, 102.2867 17.…\n 3  1.65  0.00351 High-High Khon Kaen        (((102.7072 17.08713, 102.708 17.0…\n 4  2.13  0.0324  High-High Udon Thani       (((102.0581 18.0862, 102.0583 18.0…\n 5  0.119 0.0218  High-High Nong Khai        (((103.2985 18.29698, 103.2984 18.…\n 6  0.283 0.0122  High-High Maha Sarakham    (((103.1562 16.6425, 103.1567 16.6…\n 7  2.14  0.00191 High-High Kalasin          (((103.584 17.09981, 103.5845 17.0…\n 8  0.880 0.0377  High-High Sakon Nakhon     (((103.5404 18.06785, 103.5405 18.…\n 9  0.428 0.00849 Low-Low   Nakhon Sawan     (((100.0266 16.189, 100.0267 16.18…\n10  0.705 0.0359  Low-Low   Kamphaeng Phet   (((99.48875 16.91044, 99.48883 16.…\n11 -0.446 0.0493  Low-High  Phatthalung      (((99.96416 7.90199, 99.9642 7.901…\n```\n\n\n:::\n:::\n\n\n\n#### 6.1.2 **Visualising Local Moran's I**\n\nUsing the following code, we can visualise the significant clusters and outliers on a map for each year.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa2017_sig <- lisa2017 %>%\n  filter(p_ii < 0.05)\n\nlisa2017map <- tm_shape(lisa2017) +\n  tm_polygons() +\ntm_shape(lisa2017_sig) +\n  tm_fill(\"median\") +\n  tm_borders(alpha = 0.5)\n\nlisa2018_sig <- lisa2018 %>%\n  filter(p_ii < 0.05)\n\nlisa2018map <- tm_shape(lisa2018) +\n  tm_polygons() +\ntm_shape(lisa2018_sig) +\n  tm_fill(\"median\") +\n  tm_borders(alpha = 0.5)\n\nlisa2019_sig <- lisa2019 %>%\n  filter(p_ii < 0.05) \n\nlisa2019map <- tm_shape(lisa2019) +\n  tm_polygons() +\ntm_shape(lisa2019_sig) +\n  tm_fill(\"median\") +\n  tm_borders(alpha = 0.5)\n\nlisa2020_sig <- lisa2020 %>%\n  filter(p_ii < 0.05)\n\nlisa2020map <- tm_shape(lisa2020) +\n  tm_polygons() +\ntm_shape(lisa2020_sig) +\n  tm_fill(\"median\") +\n  tm_borders(alpha = 0.5)\n\nlisa2021_sig <- lisa2021 %>%\n  filter(p_ii < 0.05)\n\nlisa2021map <- tm_shape(lisa2021) +\n  tm_polygons() +\ntm_shape(lisa2021_sig) +\n  tm_fill(\"median\") +\n  tm_borders(alpha = 0.5)\n\nlisa2022_sig <- lisa2022 %>%\n  filter(p_ii < 0.05)\n\nlisa2022map <- tm_shape(lisa2022) +\n  tm_polygons() +\ntm_shape(lisa2022_sig) +\n  tm_fill(\"median\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(lisa2017map, lisa2018map, lisa2019map, lisa2020map, lisa2021map, lisa2022map, asp = 1, nrow = 2)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\nFrom the maps, we can see that in 2017, there were two significant High-High clusters (consisting of provinces that, similar to their neighbours, had high drug-related case levels), located in Southern and Central Thailand respectively. The cluster in Central Thailand, including provinces like Chachoengsao and Chonburi, continues to be significant until 2020.\n\nThroughout this period, Samut Sakhon province, also in Central Thailand, is a notable outlier, having relatively low drug-related case levels in contrast to its neighbours.\n\nIn 2021, a significant Low-Low cluster emerges in Western Thailand.\n\nIn 2022, a significant High-High cluster in Northeastern Thailand emerges, consisting of provinces such as Khon Kaen and Udon Thani, and comprising a much larger area than the clusters previously identified. Statistically significant spatial autocorrelation in drug abuse levels had not previously been observed in this region, and this new trend is concerning as it suggests that there are some recently-emerged factors facilitating the spread of drug abuse here.\n\n### 6.2 Hot and Cold Spot Analysis\n\nAn alternative spatial statistics to detect spatial anomalies is the Getis and Ord’s Gi\\* statistics (Getis and Ord, 1972; Ord and Getis, 1995). It looks at neighbours within a defined proximity to identify where either high or low values clutser spatially. Here, statistically significant hot-spots are recognised as areas of high values where other areas within a neighbourhood range also share high values.\n\n### 6.2.1 **Computing Inverse Distance Weights**\n\nAs usual, we will need to derive a spatial weight matrix before we can compute local Gi\\* statistics. Code chunk below will be used to derive a spatial weight matrix by using sfdep functions and tidyverse approach.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_idw <- thailand_drugs %>%\n  mutate(nb = include_self(st_contiguity(geometry)),\n         wts = st_inverse_distance(nb, geometry, scale = 1, alpha = 1),\n         .before = 1)\n```\n:::\n\n\n\nWe proceed to compute the local Gi\\* statistics for each year.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\n\nHCSA2017 <- wm_idw %>% \n  mutate(local_Gi = local_gstar_perm(\n    .$\"2017\", nb, wts, nsim = 99),\n         .before = 1) %>%\n  unnest(local_Gi)\n\n\nHCSA2018 <- wm_idw %>% \n  mutate(local_Gi = local_gstar_perm(\n    .$\"2018\", nb, wts, nsim = 99),\n         .before = 1) %>%\n  unnest(local_Gi)\n\n\nHCSA2019 <- wm_idw %>% \n  mutate(local_Gi = local_gstar_perm(\n    .$\"2019\", nb, wts, nsim = 99),\n         .before = 1) %>%\n  unnest(local_Gi)\n\n\nHCSA2020 <- wm_idw %>% \n  mutate(local_Gi = local_gstar_perm(\n    .$\"2020\", nb, wts, nsim = 99),\n         .before = 1) %>%\n  unnest(local_Gi)\n\n\nHCSA2021 <- wm_idw %>% \n  mutate(local_Gi = local_gstar_perm(\n    .$\"2021\", nb, wts, nsim = 99),\n         .before = 1) %>%\n  unnest(local_Gi)\n\n\nHCSA2022 <- wm_idw %>% \n  mutate(local_Gi = local_gstar_perm(\n    .$\"2022\", nb, wts, nsim = 99),\n         .before = 1) %>%\n  unnest(local_Gi)\n```\n:::\n\n\n\nBy mapping the local Gi\\* statistics, we can identify hot spot and cold spot areas. A hot spot area is an area where where features with high values (i.e. hot spots) cluster spatially, while a low spot area is one where features with low values (cold spots) cluster spatially. Unlike when we use the local Moran's I statistic, outliers are not identified. Moreover, unlike the local Moran's I statistic,\n\nWe focus only on plotting the significant hot spot and cold spot areas, where p_sim \\< 0.05.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA2017_sig <- HCSA2017 %>%\n  filter(p_sim < 0.05)\n  \nHCSA2017_map <- tm_shape(HCSA2017) +\n  tm_polygons() +\ntm_shape(HCSA2017_sig) +\n  tm_fill(\"cluster\") +\n  tm_borders(alpha = 0.5)\n\nHCSA2018_sig <- HCSA2018 %>%\n  filter(p_sim < 0.05)\n  \nHCSA2018_map <- tm_shape(HCSA2018) +\n  tm_polygons() +\ntm_shape(HCSA2018_sig) +\n  tm_fill(\"cluster\") +\n  tm_borders(alpha = 0.5)\n\nHCSA2019_sig <- HCSA2019 %>%\n  filter(p_sim < 0.05)\n  \nHCSA2019_map <- tm_shape(HCSA2019) +\n  tm_polygons() +\ntm_shape(HCSA2019_sig) +\n  tm_fill(\"cluster\") +\n  tm_borders(alpha = 0.5)\n\nHCSA2019_sig <- HCSA2019 %>%\n  filter(p_sim < 0.05)\n  \nHCSA2019_map <- tm_shape(HCSA2019) +\n  tm_polygons() +\ntm_shape(HCSA2019_sig) +\n  tm_fill(\"cluster\") +\n  tm_borders(alpha = 0.5)\n\nHCSA2020_sig <- HCSA2020 %>%\n  filter(p_sim < 0.05)\n  \nHCSA2020_map <- tm_shape(HCSA2020) +\n  tm_polygons() +\ntm_shape(HCSA2020_sig) +\n  tm_fill(\"cluster\") +\n  tm_borders(alpha = 0.5)\n\nHCSA2020_sig <- HCSA2020 %>%\n  filter(p_sim < 0.05)\n  \nHCSA2020_map <- tm_shape(HCSA2020) +\n  tm_polygons() +\ntm_shape(HCSA2020_sig) +\n  tm_fill(\"cluster\") +\n  tm_borders(alpha = 0.5)\n\nHCSA2021_sig <- HCSA2021 %>%\n  filter(p_sim < 0.05)\n  \nHCSA2021_map <- tm_shape(HCSA2021) +\n  tm_polygons() +\ntm_shape(HCSA2021_sig) +\n  tm_fill(\"cluster\") +\n  tm_borders(alpha = 0.5)\n\nHCSA2022_sig <- HCSA2022 %>%\n  filter(p_sim < 0.05)\n  \nHCSA2022_map <- tm_shape(HCSA2022) +\n  tm_polygons() +\ntm_shape(HCSA2022_sig) +\n  tm_fill(\"cluster\") +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_arrange(HCSA2017_map, HCSA2018_map, HCSA2019_map, HCSA2020_map, HCSA2021_map, HCSA2022_map, asp = 1, nrow = 2)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\nThe emergence of a significant cold spot area in Western Thailand in 2021 is now very obvious.\n\n## **7.0 Emerging Hot Spot Analysis**\n\nEmerging hot spot analysis (EHSA) allows us to evaluate how hot and cold spots are changing over time. It combines the traditional exploratory spatial data analysis technique of hot spot analysis using the Getis-Ord Gi\\* statistic with the traditional time-series Mann-Kendall test for monotonic trends.\n\nWe will perform EHSA analysis by using *emerging_hotspot_analysis()*. This requires us to first create a spacetime object. The following steps are inspired by a previous student in this course, [Khant (2024)](#0).\n\nThere are four important data required to create the spacetime object:\n\n-   **data**: a tibble data frame object containing location and time identifiers\n\n-   **geometry**: an sf object containing location identifiers\n\n-   **location identifier**: a common column between data and geometry\n\n-   **time**: a column in data that includes temporal information.\n\nTo achieve this, we first use the *pivot_longer()* function of **dplyr** to transform `thailand_drugs` into a tibble data frame `data` with a single column each for the location identifers (ADM1_EN) and time identifiers (year). Here, the argument names_transform is used to ensure that the year column is of integer type.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- thailand_drugs %>% \n  pivot_longer(cols = 2:7, names_to = \"year\", values_to = \"cases\", names_transform = list(year = as.integer)) %>%\n  select(ADM1_EN, year, cases) %>%\n  as_tibble()\n```\n:::\n\n\n\nWe can now create the spacetime object using the *spacetime()* function of **sfdep**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspt <- spacetime (.data = data, .geometry = thailand, .loc_col = \"ADM1_EN\", .time_col = \"year\")\n```\n:::\n\n\n\n[A spacetime object is a spacetime cube if every location has a value for every time index](https://sfdep.josiahparry.com/articles/spacetime-s3.html#spatio-temporal-grids-and-spacetime). We use [*is_spacetime_cube()*](https://sfdep.josiahparry.com/reference/is_spacetime_cube) to very that our newly created `spt` object is a spacetime cube, and *validate_spacetime()* to ensure that it is validly constructed.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_spacetime_cube(spt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\nWe can perform the EHSA analysis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nehsa <- emerging_hotspot_analysis(\n  x = spt, \n  .var = \"cases\", \n  k = 1, \n  nsim = 99,\n  threshold = 0.05\n)\n\nglimpse(ehsa)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 77\nColumns: 4\n$ location       <chr> \"Bangkok\", \"Samut Prakan\", \"Nonthaburi\", \"Pathum Thani\"…\n$ tau            <dbl> 0.59999996, -0.06666666, 0.06666666, 0.33333331, 0.5999…\n$ p_value        <dbl> 0.13285494, 1.00000000, 1.00000000, 0.45237041, 0.13285…\n$ classification <chr> \"no pattern detected\", \"sporadic coldspot\", \"sporadic h…\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ehsa, aes(y = classification)) +\n  geom_bar(aes(fill = classification))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n\nWe can see that most provinces have no pattern detected, while sporadic coldspots and sporadic hotspots are the next most common classes of provinces.\n\nWe can further limit our observations to provinces that fall into an EHSA class with p-value \\< 0.05.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = filter(ehsa, p_value < 0.05), aes(y = classification)) +\n  geom_bar(aes(fill = classification))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n\nAs we can see, most of our observations from before were not statistically significant. Only 4 classes of hotspots and coldspots remain: consecutive coldspots and hotspots, and intensifying coldspots and hotspots.\n\nWe visualise these on a map using functions of the **tmap** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nehsa_map <- thailand_drugs %>%\n  left_join(filter(ehsa, p_value < 0.05), by = c(\"ADM1_EN\" = \"location\"))\n\ntm_shape(ehsa_map) +\n  tm_fill(\"classification\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Emerging Hotspots & Coldspots \\nof Drug Abuse in Thailand (2017-2022)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.text.size = 0.45,\n            legend.height = 0.5, \n            legend.width = 0.5, \n            asp = 1,\n            frame = TRUE)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Take-home_Ex02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}