{
  "hash": "4006686fec2a8bca4467f821bdad08b2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-Class Exercise 6\"\nauthor: \"Immanuel Leong\"\ndate: \"September 23, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n## In-class Exercise 6: Global and Local Measures of Spatial Autocorrelation\n\n-   sfdep package: sf and tidyverse friendly interface to spdep package (allows us to use tibble format); utilises list columns to make this interface possible\n\n### Installing and loading packages\n\nWe load sf, sfdep, tmap and tidyverse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, tmap, tidyverse)\n```\n:::\n\n\nImport the necessary datasets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n\nhunan <- st_read(dsn = \"data/geospatial\", layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `C:\\ImmanuelLeong\\IS415-Geospatial\\In-class_Ex\\In-class_Ex06\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\n# Should be finding out projections\n```\n:::\n\n\nCombine the data frames.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_GDPPC <- left_join(hunan, hunan2012) %>%\n  select(1:4, 7, 15)\n```\n:::\n\n\n### Global Measures of Spatial Association\n\n**Step 1: Deriving Queen's Contiguity Weights**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- hunan_GDPPC %>%\n  mutate(nb = st_contiguity(geometry),\n         wt = st_weights(nb, style = \"W\"),\n         .before = 1)\n\n#.before = 1 inserts the two new columns to the left of the existing columns\n```\n:::\n\n\nst_contiguity() builds contiguity matrix\n\nst_weights() builds weight matrix based on nb\n\n-   nb: neighbour list object as created by st_neighbors\n\n-   style: default \"W\" for row-standardised weights (sums over all links to n)\n\n-   allow_zero: if TRUE, assigns zero as lagged value to zone without neighbours\n\n**Computing Global Moran's I**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoranI <- global_moran(wm_q$GDPPC, wm_q$nb, wm_q$wt)\n\nglimpse(moranI)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ I: num 0.301\n $ K: num 7.64\n```\n\n\n:::\n:::\n\n\n**Performing Global Moran's I Test**\n\nIn general, Moran's I test will be performed instead of just computing the Moran's I statistic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_test(wm_q$GDPPC, wm_q$nb, wm_q$wt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  x  \nweights: listw    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\n\nAt alpha = 0.05, there is sufficient evidence to reject the null hypothesis of a random distribution. Since the Moran I statistic is positive but small, we infer that there is relatively weak clustering.\n\n**Performing Global Moran's Permutation Test**\n\nIn practice, Monte Carlo simulation should be used to perform the statistical test. We can skip the previous step and proceed to this immediately. We must use set.seed() before simulation to ensure that the computation is reproducible.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\nglobal_moran_perm(wm_q$GDPPC, wm_q$nb, wm_q$wt, nsim = 99)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.30075, observed rank = 100, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n\n\n:::\n:::\n\n\nAt alpha = 0.05, there is sufficient evidence to reject the null hypothesis of a random distribution. Since the Moran I statistic is positive but small, we infer that there is relatively weak clustering.\n\n**Computing local Moran's I**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa <- wm_q %>%\n  mutate(local_moran = local_moran(GDPPC, nb, wt, nsim = 99),\n         .before = 1) %>%\n  unnest(local_moran)\n```\n:::\n\n\nImportant output fields:\n\n-   ii: local Moran's I\n\n-   3 different p-values based on 3 different methods (p_ii is base method, p_ii_sim is using simulation (without replacement), p_folded_sim based on simulation with different algorithm (with replacement)) - choose any of these, but be consistent\n\n-   mean, median, pysal: 3 different methods to label hotspots and coldspots - use median if data is highly skewed\n\n**Visualising local Moran's I**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n\nmap1 <- tm_shape(lisa) +\n  tm_fill(\"ii\") +\n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(main.title = \"Local Moran's I of GDPPC\", main.title.size = 1)\n```\n:::\n\n\n**Visualising p-value of local Moran's I**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap2 <- tm_shape(lisa) +\n  tm_fill(\"p_ii_sim\", breaks = c(0, 0.001, 0.01, 0.05, 1), labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not sig\")) +\n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(main.title = \"P-values of Local Moran's I of GDPPC\", main.title.size = 1)\n  \ntmap_arrange(map1, map2, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex06_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nFor p-values, the appropriate classification should be 0.001, 0.01, 0.05, and not significant instead of using the default.\n\n**LISA Map**\n\nLISA map is a categorical map showing outliers and clusters.\n\n-   Two types of outliers: High-Low (High surrounded by Low) and Low-High (Low surrounded by High)\n\n-   Two types of clusters: High-High and Low-Low\n\nLISA map is an interpreted map combining local Moran's I of geographical areas and respective p-values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_sig <- lisa %>%\n  filter(p_ii < 0.05)\n\ntmap_mode(\"plot\")\n\ntm_shape(lisa) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(lisa_sig) +\n  tm_fill(\"mean\") +\n  tm_borders(alpha = 0.4)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex06_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n**Computing local Gi\\* statistics**\n\nAs usual, we will need to derive a spatial weight matrix before we can compute local Gi\\*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_idw <- hunan_GDPPC %>%\n  mutate(nb = st_contiguity(geometry),\n         wts = st_inverse_distance(nb, geometry, scale = 1, alpha = 1),\n         .before = 1)\n```\n:::\n\n\nGi\\* and local Gi\\* are distance-based spatial statistics. Hence, distance methods should be used to derive the spatial weight matrix.\n\nNext, we compute the local Gi\\*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA <- wm_idw %>%\n  mutate(local_Gi = local_gstar_perm(GDPPC, nb, wt, nsim = 99),\n         .before = 1) %>%\n  unnest(local_Gi)\n\nHCSA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 88 features and 18 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n# A tibble: 88 × 19\n   gi_star cluster   e_gi     var_gi std_dev p_value p_sim p_folded_sim skewness\n     <dbl> <fct>    <dbl>      <dbl>   <dbl>   <dbl> <dbl>        <dbl>    <dbl>\n 1  0.0416 Low     0.0114 0.00000641  0.0493 9.61e-1  0.7          0.35    0.875\n 2 -0.333  Low     0.0106 0.00000384 -0.0941 9.25e-1  1            0.5     0.661\n 3  0.281  High    0.0126 0.00000751 -0.151  8.80e-1  0.9          0.45    0.640\n 4  0.411  High    0.0118 0.00000922  0.264  7.92e-1  0.6          0.3     0.853\n 5  0.387  High    0.0115 0.00000956  0.339  7.34e-1  0.62         0.31    1.07 \n 6 -0.368  High    0.0118 0.00000591 -0.583  5.60e-1  0.72         0.36    0.594\n 7  3.56   High    0.0151 0.00000731  2.61   9.01e-3  0.06         0.03    1.09 \n 8  2.52   High    0.0136 0.00000614  1.49   1.35e-1  0.2          0.1     1.12 \n 9  4.56   High    0.0144 0.00000584  3.53   4.17e-4  0.04         0.02    1.23 \n10  1.16   Low     0.0104 0.00000370  1.82   6.86e-2  0.12         0.06    0.416\n# ℹ 78 more rows\n# ℹ 10 more variables: kurtosis <dbl>, nb <nb>, wts <list>, NAME_2 <chr>,\n#   ID_3 <int>, NAME_3 <chr>, ENGTYPE_3 <chr>, County <chr>, GDPPC <dbl>,\n#   geometry <POLYGON [°]>\n```\n\n\n:::\n:::\n\n\n**Visualising Gi\\***\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n\ntm_shape(HCSA) +\n  tm_fill(\"gi_star\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Gi*\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex06_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nHCSA uses spatial weights to identify locations of statistically significant hot spots and cold spots in a spatially weighted attribute.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA_sig <- HCSA %>%\n  filter(p_sim < 0.05)\n\ntm_shape(HCSA) +\n  tm_polygons +\n  tm_borders(alpha = 0.5) +\ntm_shape(HCSA_sig) +\n  tm_fill(\"gi_star\") +\n  tm_borders(alpha = 0.4) +\n  tm_layout(main.title = \"HCSA\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex06_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nFigure above reveals there is one hot spot area and two cold spot areas. The hot spot areas coincide with the High-High cluster identified using local Moran's I.\n",
    "supporting": [
      "In-class_Ex06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}